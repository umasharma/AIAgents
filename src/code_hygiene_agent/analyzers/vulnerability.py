"""
Vulnerability scanner for Python dependencies.

This module provides vulnerability scanning capabilities using pip-audit
and safety to identify security issues in Python dependencies.
"""

import json
import time
from pathlib import Path

from ..utils.exceptions import VulnerabilityScannError
from .base import AnalysisIssue, AnalysisResult, BaseAnalyzer


class VulnerabilityAnalyzer(BaseAnalyzer):
    """Analyzes Python projects for vulnerable dependencies."""

    def __init__(self) -> None:
        super().__init__("vulnerability")

    @property
    def required_tools(self) -> list[str]:
        """External tools required for vulnerability scanning."""
        tools = []
        if hasattr(self, "_use_pip_audit") and self._use_pip_audit:
            tools.append("pip-audit")
        if hasattr(self, "_use_safety") and self._use_safety:
            tools.append("safety")
        return tools or ["pip-audit"]  # Default to pip-audit

    @property
    def supported_file_types(self) -> list[str]:
        """File types that contain dependency information."""
        return [".txt", ".toml", ".cfg", ".in"]

    async def analyze(self, project_path: Path) -> AnalysisResult:
        """
        Scan project for vulnerable dependencies.

        Args:
            project_path: Path to project root

        Returns:
            AnalysisResult with vulnerability findings
        """
        start_time = time.time()
        result = self._create_base_result(project_path, start_time)

        try:
            self.logger.info(
                "Starting vulnerability analysis", project_path=str(project_path)
            )

            # Find dependency files
            dependency_files = self._find_dependency_files(project_path)
            if not dependency_files:
                self.logger.warning(
                    "No dependency files found", project_path=str(project_path)
                )
                result.success = True
                result.execution_time = time.time() - start_time
                return result

            # Run pip-audit analysis
            if await self._tool_available("pip-audit"):
                pip_audit_issues = await self._run_pip_audit(
                    project_path, dependency_files
                )
                result.issues.extend(pip_audit_issues)

            # Run safety analysis if enabled and available
            from ..config.settings import settings

            if settings.analysis.enable_safety and await self._tool_available("safety"):
                safety_issues = await self._run_safety(project_path)
                result.issues.extend(safety_issues)

            result.success = True
            result.metadata = {
                "dependency_files": [str(f) for f in dependency_files],
                "tools_used": [
                    tool
                    for tool in self.required_tools
                    if await self._tool_available(tool)
                ],
                "total_vulnerabilities": len(result.issues),
            }

            self.logger.info(
                "Vulnerability analysis completed",
                project_path=str(project_path),
                vulnerabilities_found=len(result.issues),
                execution_time=time.time() - start_time,
            )

        except Exception as e:
            result.error_message = str(e)
            result.success = False
            self.logger.error(
                "Vulnerability analysis failed",
                project_path=str(project_path),
                error=str(e),
                error_type=type(e).__name__,
            )
            raise VulnerabilityScannError(
                f"Vulnerability analysis failed for {project_path}", cause=e
            ) from e

        result.execution_time = time.time() - start_time
        return result

    def _find_dependency_files(self, project_path: Path) -> list[Path]:
        """Find dependency specification files in the project."""
        dependency_files = []

        # Common dependency file patterns
        patterns = [
            "requirements*.txt",
            "pyproject.toml",
            "setup.py",
            "setup.cfg",
            "Pipfile",
            "poetry.lock",
            "*.requirements",
        ]

        for pattern in patterns:
            dependency_files.extend(project_path.glob(pattern))
            # Also check subdirectories for some patterns
            if pattern in ["requirements*.txt", "*.requirements"]:
                dependency_files.extend(project_path.glob(f"*/{pattern}"))

        return list(set(dependency_files))  # Remove duplicates

    async def _run_pip_audit(
        self, project_path: Path, dependency_files: list[Path]
    ) -> list[AnalysisIssue]:
        """Run pip-audit on the project."""
        issues = []

        for dep_file in dependency_files:
            try:
                # Run pip-audit with JSON output
                command = ["pip-audit", "--format=json", "--requirement", str(dep_file)]

                result = await self._run_command(command, cwd=project_path)

                if result.returncode == 0:
                    # No vulnerabilities found
                    continue
                elif result.returncode == 1:
                    # Vulnerabilities found, parse output
                    if result.stdout:
                        vulnerabilities = json.loads(result.stdout.decode("utf-8"))
                        issues.extend(
                            self._parse_pip_audit_output(vulnerabilities, dep_file)
                        )
                else:
                    # Error occurred
                    error_msg = (
                        result.stderr.decode("utf-8")
                        if result.stderr
                        else "Unknown error"
                    )
                    self.logger.warning(
                        "pip-audit failed for dependency file",
                        file=str(dep_file),
                        error=error_msg,
                    )

            except Exception as e:
                self.logger.warning(
                    "Failed to analyze dependency file with pip-audit",
                    file=str(dep_file),
                    error=str(e),
                )

        return issues

    def _parse_pip_audit_output(
        self, vulnerabilities: dict, dep_file: Path
    ) -> list[AnalysisIssue]:
        """Parse pip-audit JSON output into AnalysisIssue objects."""
        issues = []

        for vuln in vulnerabilities.get("vulnerabilities", []):
            package = vuln.get("package", "unknown")
            installed_version = vuln.get("installed_version", "unknown")

            for spec in vuln.get("specs", []):
                issue_id = f"pip_audit_{package}_{spec.get('id', 'unknown')}"

                # Determine severity based on CVSS score or description
                severity = self._determine_severity(spec)

                issue = AnalysisIssue(
                    id=issue_id,
                    title=f"Vulnerable dependency: {package}",
                    description=spec.get(
                        "details",
                        f"Package {package} version {installed_version} has a known vulnerability",
                    ),
                    file_path=str(dep_file),
                    severity=severity,
                    category="security",
                    analyzer="pip-audit",
                    rule_id=spec.get("id"),
                    suggestion=f"Update {package} to version {spec.get('fix_versions', ['latest'])[0] if spec.get('fix_versions') else 'latest'}",
                    references=[
                        url for url in spec.get("aliases", []) if url.startswith("http")
                    ],
                )

                issues.append(issue)

        return issues

    async def _run_safety(self, project_path: Path) -> list[AnalysisIssue]:
        """Run safety check on the project."""
        issues = []

        try:
            # Run safety with JSON output
            command = ["safety", "check", "--json"]
            result = await self._run_command(command, cwd=project_path)

            if result.stdout:
                safety_data = json.loads(result.stdout.decode("utf-8"))
                issues.extend(self._parse_safety_output(safety_data))

        except Exception as e:
            self.logger.warning("Failed to run safety check", error=str(e))

        return issues

    def _parse_safety_output(self, safety_data: list) -> list[AnalysisIssue]:
        """Parse safety JSON output into AnalysisIssue objects."""
        issues = []

        for vuln in safety_data:
            package = vuln.get("package_name", "unknown")
            installed_version = vuln.get("installed_version", "unknown")

            issue_id = f"safety_{package}_{vuln.get('vulnerability_id', 'unknown')}"

            issue = AnalysisIssue(
                id=issue_id,
                title=f"Vulnerable dependency: {package}",
                description=vuln.get(
                    "advisory",
                    f"Package {package} version {installed_version} has a known vulnerability",
                ),
                severity=self._map_safety_severity(vuln.get("severity")),
                category="security",
                analyzer="safety",
                rule_id=vuln.get("vulnerability_id"),
                suggestion=f"Update {package} to a safe version",
                references=[],
            )

            issues.append(issue)

        return issues

    def _determine_severity(self, spec: dict) -> str:
        """Determine severity level from vulnerability specification."""
        # Try to extract CVSS score or severity from the spec
        details = spec.get("details", "").lower()

        if any(
            word in details
            for word in ["critical", "remote code execution", "privilege escalation"]
        ):
            return "critical"
        elif any(
            word in details for word in ["high", "arbitrary code", "sql injection"]
        ):
            return "high"
        elif any(word in details for word in ["medium", "xss", "csrf"]):
            return "medium"
        elif any(word in details for word in ["low", "information disclosure"]):
            return "low"
        else:
            return "medium"  # Default to medium

    def _map_safety_severity(self, severity: str | None) -> str:
        """Map safety severity to standard severity levels."""
        if not severity:
            return "medium"

        severity_lower = severity.lower()
        if severity_lower in ["critical", "high", "medium", "low"]:
            return severity_lower
        else:
            return "medium"

    async def _tool_available(self, tool_name: str) -> bool:
        """Check if a specific tool is available."""
        availability = await self.check_tool_availability()
        return availability.get(tool_name, False)
